/**
 * 作用域链：定义时确定，静态作用域
 * 执行上下文：一个栈，全局执行上下文先入栈，然后执行函数的时候，把函数上下文压入栈，执行完就pop，全局
 * 在最底部
 * 
 * 进入执行上下文：还没有执行代码
 * 变量对象包括： 函数所有形参，由名称和对应值组成的一个变量对象的属性被创建，没有实参，属性值设为undefined
 *   函数声明：由名称和对应值（函数对象function-object）组成一个变量对象的属性值被创建
 *      如果变量对象已经存在相同名称属性，则完全替换这个属性
 *   变量声明：由名称和对应值（undefined）组成一个变量对象的属性被创建
 *      如果变量名称和已经声明的形参或函数相同，则变量声明不会干扰这些已经存在的这类属性
 * 
 * 作用域链：函数作用域在函数定义时就决定了，[[scope]]
 * 函数创建时候保存所有父变量对象到其中，理解为父变量对象的层级链，但是并不代表完整作用域链
 *      创建函数保存的是根据词法生成的作用域链，执行时候会复制这个作用域链，作为自己作用域链的初始化
 *      然后根据环境生成变量对象，然后将这个变量对象添加到这个复制的作用域链，
 * 闭包：函数+函数能够反问的自由变量
 *  理论角度：所有函数都是闭包，可以反问全局变量，使用最外层作用域
 *  实践角度：即使创建他的上下文已经销毁，他任然存在比如内部函数从父函数中返回
 *          在代码中引用了自由变量
 * 作用域链使得父函数的上下文销毁了，js在内存中还是保存了父函数上下文呢的ao对象
 * 依然可以通过子函数作用域链找到他
 * 
 * 参数按照值来传递：基本类型是按值传递，引用类型是传递对象的引用的副本
 *  引用类型传递如果内部修改了形参的值，修改成基本类型，不会改变引用，修改成引用类型，会改变
 *      外层传入的实参
 */
/**
 * 类数组对象： {1: 'a', 2: 'b', 3: 'c', length: 3}
 * 转数组：Array.prototype.push.call(arrlike, 'def');
 * arguments document.getElementsByTagName('div') ...
 * 函数体中arguments指代函数的Arguments对象
 * 传入的参数，实参和arguments是共享的，没有传入的参数，实参和arguments不共享，改变其中之一
 * 另外一个不变
 * 在严格模式中，都不会共享
 * 
 * 创建对象多种方式和优缺点
 * 
 * 
 * 
 */

